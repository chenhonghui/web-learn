

js 闭包： 缓存

Js 对象指向一个地址，

js 作用域： 

```javascript
function foo() { 
   var a = 3;
   bar(); 
}
function bar() {
   console.log( a ); // 2
}
var a = 2;
foo(); 
```

```javascript
var a = 'a';
var b = 'b';
var c = 'c';
function foo() { 
   this.a = 'foo-a'; // this 指向window；
   var b = 'foo-b';
   foo.c = 'foo-c';
   bar.call(foo); // 改变this指向；
}

function bar() {
  // foo-a b c
  console.log(a , b, c);
  // undefined undefined "foo-c"
	console.log(this.a,this.b,this.c); // this 指向foo；
  // 总结：this不同于作用域
}
foo(); 
```

```javascript
function foo() {
    var a = 2;
    function bar() { 
        console.log( this ); // window
    }
    bar(); 
}
foo(); 
```

```javascript
function foo(el) {
	console.log( el, this.id );
}
var obj = {
	id: "awesome"
};
// 调用 foo(..) 时把 this 绑定到 
obj [1, 2, 3].forEach( foo, obj );
// 1 awesome 2 awesome 3 awesome
```

```javascript
function foo(something) {
  this.a = something;
}
var obj1 = { 
  foo: foo
};
var obj2 = {};

obj1.foo( 2 ); // 2

obj1.foo.call( obj2, 3 ); 
console.log( obj2.a ); // 3

var bar = new obj1.foo( 4 );

console.log( obj1.a ); // 2 
console.log( bar.a ); // 4
```



```javascript
function foo(p1,p2) { 
  this.val = p1 + p2;
}
// 之所以使用 null 是因为在本例中我们并不关心硬绑定的 this 是什么 
// 反正使用 new 时 this 会被修改
var bar = foo.bind( null, "p1" ); // window;
var baz = new bar( "p2" ); 
baz.val; // p1p2
bar('p3'); // window.val = p1p3;

```



```javascript
function foo(p1,p2) { 
  this.val = p1 + p2;
  console.log(this);
}
// 之所以使用 null 是因为在本例中我们并不关心硬绑定的 this 是什么 
// 反正使用 new 时 this 会被修改
var zero = {
  a : 'zero',
  foo: foo
}

var bar = new zero.foo( "p2" ); 
bar.val; // p1p2


var obj1 = {
  a:1
};
var obj2 = {
  a: 2
}
function foo(){
  console.log(this.a)
}
foo.bind(obj1).bind(obj2)();
```

